<!DOCTYPE html>
<html>

<head>
  <title>3D Maze - Multi-level [Rapier.js]</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Roboto', Arial, sans-serif;
      font-size: 18px;
      color: white;
      background-color: black;
    }

    .gameCanvas {
      width: 100vw;
      height: 100vh;
    }

    #ui {
      position: absolute;
      top: 5px;
      left: 5px;
      text-shadow: 1px 1px 2px black;
    }

    #ui,
    #ui p {
      padding: 0px;
      margin: 0px;
    }

    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0);
    }

    #infoBlock {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      font-size: 18px;
    }

    #infoBlock * {
      margin: 1px;
      padding: 5px;
      text-align: center;
      font-size: 16px;
    }

    #infoBlock h1 {
      font-size: 36px;
    }

    #playButton,
    #regenerateMazeButton,
    #regenerateLightingColorsButton,
    #resetSettingsButton {
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="blocker">
    <div id="infoBlock">
      <h1 id="playButton">Click to play</h1>
      <div>
        <p>
          Your task is to find the <span style="color: red">red</span> box
        </p>
      </div>
      <div>
        <span>Maze size:</span>
        <label>
          <input type="number" id="mazeZ" min="1" max="100" value="3">
        </label>
        x
        <label>
          <input type="number" id="mazeY" min="5" max="100" value="10">
        </label>
        x
        <label>
          <input type="number" id="mazeX" min="5" max="100" value="10">
        </label>
      </div>
      <div>
        <label>
          <span>Increase the size every N mazes (0:disable|1-20):</span>
          <input type="number" id="autoModeN" min="1" max="20" value="0">
        </label>
      </div>
      <div>
        <label>
          <span>Wall density (10-90%):</span>
          <input type="number" id="wallDensity" min="10" max="90" value="30">
        </label>
      </div>
      <div>
        <label>
          <span>Movement speed (1-20):</span>
          <input type="number" id="speed" min="1" max="20" value="5">
        </label>
      </div>
      <div>
        <label>
          <span>Max interfering bots (0-20):</span>
          <input type="number" id="botsNumber" min="0" max="20" value="0">
        </label>
      </div>
      <div>
        <label>
          <span>Interfering bots shoot:</span>
          <select id="botsShoot">
            <option value="simple">Simple</option>
            <option value="hard">Hard</option>
            <option value="disable" selected>Disable</option>
          </select>
        </label>
      </div>
      <div>
        <label>
          <span>Interfering bots speed (1-10):</span>
          <input type="number" id="botsSpeed" min="1" max="10" value="1">
        </label>
      </div>
      <div>
        <label>
          <span>Color accent:</span>
          <select id="colorAccent">
            <option value="neutral">Neutral</option>
            <option value="red">Red</option>
            <option value="green">Green</option>
            <option value="blue">Blue</option>
            <option value="cyan">Cyan</option>
            <option value="magenta">Magenta</option>
            <option value="yellow">Yellow</option>
            <option value="orange">Orange</option>
            <option value="random-per-maze">Random per maze</option>
            <option value="random-per-side">Random per side</option>
          </select>
        </label>
      </div>
      <div>
        <button id="regenerateLightingColorsButton">Regenerate colors & lighting</button>
        <button id="regenerateMazeButton">Regenerate maze</button>
      </div>
      <div>
        <button id="resetSettingsButton">Reset settings</button>
      </div>
    </div>
  </div>
  <canvas id="gameCanvas1" class="gameCanvas"></canvas>
  <div id="ui">
    <p>Mouse: Look | WASD/↑←↓→: Move | C or Space: Jump | T or Shift: overdrive mode</p>
    <p>G: Start position | U: Bots to their start positions | P: Save Image</p>
    <p id="timeInfo"></p>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
        "@dimforge/rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import RAPIER from '@dimforge/rapier3d-compat';

    class GameMap {
      constructor(canvas, initMazeZ = 5, initMazeY = 40, initMazeX = 40, initWallDensity = 50, initMoveSpeed = 5, colorAccent = 'random', initAutoModeN = 0, initMaxBotsNumber = 0, botsSpeed = 2, botsShoot = 'simple') {
        this.canvas = canvas;
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({
          canvas: this.canvas,
          antialias: true
        });
        this.eventsCallback = () => { };
        this.controls = new PointerLockControls(this.camera, this.renderer.domElement);
        this.controls.addEventListener('lock', () => {
          this.locked = true;
          this.eventsCallback({ event: 'lock', status: true });
        });
        this.controls.addEventListener('unlock', () => {
          this.locked = false;
          this.eventsCallback({ event: 'unlock', status: true });
        });

        this.wallThickness = 2;
        this.wallHeight = 3;
        this.wallHeightPart = 0.5; 
        this.player = {
          height: 1.8,
          radius: 0.4,
          startPosition: new THREE.Vector3(this.wallThickness, this.wallHeightPart, this.wallThickness), 
          position: new THREE.Vector3(this.wallThickness, this.wallHeightPart, this.wallThickness), 
          moveSpeed: 5,
          rapierBody: null,
          jumpImpulse: 10, 
          onGround: false, 
          justJumped: false, 
        };

        this.keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false,
          shift: false
        };
        
        this.physicsWorld = null;
        this.eventQueue = null;

        this.movingObjects = []; 
        this.projectiles = []; 

        this.maxBotsNumber = 0; 
        this.botsSpeed = 1;
        this.botsShoot = 'disable';
        this.autoModeN = 0;
        this.autoModeNCounter = 0;
        
        this.PROJECTILE_RADIUS = 0.2;
        this.PROJECTILE_MAX_DISTANCE_FACTOR = 15; 
        this.MAX_PROJECTILES_IN_SCENE = 30; 
        this.PROJECTILE_BASE_SPEED_FACTOR = 1.2; 
        this.PROJECTILE_HARD_SPEED_FACTOR = 2.0; 
        this.projectileGeometry = new THREE.SphereGeometry(this.PROJECTILE_RADIUS, 8, 8);
        this.projectileMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });


        this.setParameters({
          mazeZ: initMazeZ,
          mazeY: initMazeY,
          mazeX: initMazeX,
          wallDensity: initWallDensity,
          speed: initMoveSpeed,
          colorAccent: colorAccent,
          autoModeN: initAutoModeN,
          botsNumber: initMaxBotsNumber, 
          botsSpeed: botsSpeed,
          botsShoot: botsShoot 
        }, false);
        this.maze = this.generateRandomMaze(this.mazeY, this.mazeX, this.numFloors);

        this.walls = []; 
        this.finishBox = null; 
        
        this.frontVectorBase = new THREE.Vector3(0, 0, -1);
        this.sideVectorBase = new THREE.Vector3(1, 0, 0);
        this.prevTime = performance.now();
        this.moveBotsToStartPositions = false;
      }

      findComponents(maze) {
        const rows = maze.length;
        const cols = maze[0].length;
        const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
        const components = [];
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        function iterativeDfs(startY, startX) {
          const component = [];
          const stack = [[startY, startX]];
          while (stack.length > 0) {
            const [y, x] = stack.pop();
            if (
              y < 0 ||
              y >= rows ||
              x < 0 ||
              x >= cols ||
              visited[y][x] ||
              maze[y][x] === 1
            ) {
              continue;
            }
            visited[y][x] = true;
            component.push([y, x]);
            for (const [dy, dx] of directions) {
              const ny = y + dy;
              const nx = x + dx;
              if (
                ny >= 0 &&
                ny < rows &&
                nx >= 0 &&
                nx < cols &&
                !visited[ny][nx] &&
                maze[ny][nx] === 0
              ) {
                stack.push([ny, nx]);
              }
            }
          }
          return component;
        }
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            if (maze[y][x] === 0 && !visited[y][x]) {
              const component = iterativeDfs(y, x);
              if (component.length > 0) {
                components.push(component);
              }
            }
          }
        }
        return components;
      }

      shortestPathBetweenComponents(maze, comp1, comp2) {
        const rows = maze.length;
        const cols = maze[0].length;
        let minDistance = Infinity;
        for (let i = 0; i < comp1.length; ++i) {
          for (let j = 0; j < comp2.length; ++j) {
            const distance = Math.pow(comp1[i][0] - comp2[j][0], 2) + Math.pow(comp1[i][1] - comp2[j][1], 2);
            if (distance < minDistance) {
              minDistance = distance;
            }
          }
        }
        return minDistance;
      }

      kruskal(n, edges) {
        const parent = Array.from({ length: n }, (_, i) => i);
        function find(x) {
          if (parent[x] !== x) {
            parent[x] = find(parent[x]);
          }
          return parent[x];
        }
        function union(x, y) {
          parent[find(x)] = find(y);
        }
        const mst = [];
        edges.sort((a, b) => a[0] - b[0]); 
        for (const [w, u, v] of edges) {
          if (find(u) !== find(v)) {
            union(u, v);
            mst.push([u, v, w]);
          }
        }
        return mst;
      }

      connectComponents(maze) {
        const components = this.findComponents(maze);
        if (components.length <= 1) {
          return maze.map(row => [...row]);
        }
        const n = components.length;
        const edges = [];
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            const weight = this.shortestPathBetweenComponents(maze, components[i], components[j]);
            edges.push([weight, i, j]);
          }
        }
        const mst = this.kruskal(n, edges);
        const resultMaze = maze.map(row => [...row]);
        for (const [u, v] of mst) {
          const start = components[u][0];
          const targetSet = new Set(components[v].map(([y, x]) => `${y},${x}`));
          const queue = [[start, []]]; 
          const visited = new Set([`${start[0]},${start[1]}`]);
          while (queue.length > 0) {
            const [[y, x], path] = queue.shift();
            if (targetSet.has(`${y},${x}`)) {
              for (const [py, px] of path) {
                if (resultMaze[py][px] === 1) {
                  resultMaze[py][px] = 0;
                }
              }
              break;
            }
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dy, dx] of directions) {
              const ny = y + dy;
              const nx = x + dx;
              if (ny >= 0 && ny < maze.length && nx >= 0 && nx < maze[0].length && !visited.has(`${ny},${nx}`)) {
                visited.add(`${ny},${nx}`);
                queue.push([[ny, nx], [...path, [ny, nx]]]);
              }
            }
          }
        }
        return resultMaze;
      }

      generateRandomMaze(yMax, xMax, floors) {
        let mazes = Array(floors + 1).fill().map(() => Array(yMax).fill().map(() => Array(xMax).fill(0)));
        for (let floor = 0; floor < floors + 1; floor++) {
          const isFirstFloor = floor === 0;
          const isLastFloor = floor === floors;
          for (let y = 1; y < yMax - 1; y++) {
            for (let x = 1; x < xMax - 1; x++) {
              mazes[floor][y][x] = isLastFloor || floor >= 1 && mazes[floor - 1][y][x] === 0 || Math.random() < (this.wallDensity / 100) ? 1 : 0;
            }
          }
          for (let y = 0; y < yMax; y++) {
            mazes[floor][y][0] = 1;
            mazes[floor][y][xMax - 1] = 1;
          }
          for (let x = 0; x < xMax; x++) {
            mazes[floor][0][x] = 1;
            mazes[floor][yMax - 1][x] = 1;
          }
          if (!isLastFloor) {
            if (isFirstFloor) {
              mazes[floor][1][1] = 0;
              mazes[floor][1][xMax - 2] = 0;
              mazes[floor][yMax - 2][1] = 0;
              mazes[floor][yMax - 2][xMax - 2] = 0;
            }
            else {
              const variants = [];
              let noNeed = false;
              for (let y = 1; y < yMax - 1; y++) {
                for (let x = 1; x < xMax - 1; x++) {
                  if (mazes[floor - 1][y][x] === 0 && mazes[floor][y][x] === 0) {
                    noNeed = true;
                    break;
                  }
                  if (mazes[floor - 1][y][x] === 0 && mazes[floor][y][x] === 1) {
                    variants.push([y, x]);
                  }
                }
                if (noNeed) {
                  break;
                }
              }
              if (!noNeed && variants.length) {
                const variant = variants[Math.floor(Math.random() * variants.length)];
                mazes[floor][variant[0]][variant[1]] = 0;
              }
            }
            mazes[floor] = this.connectComponents(mazes[floor]);
          }
        }
        return mazes;
      }

      setEventsCallback(eventsCallback) {
        this.eventsCallback = eventsCallback;
      }

      setParameters(parameters, regenerate = true) {
        let changed = false;
        if (parameters['mazeZ'] != null) {
          parameters['mazeZ'] = parseInt(parameters['mazeZ']);
        }
        if (parameters['mazeZ'] != null && parameters['mazeZ'] === parameters['mazeZ'] && parameters['mazeZ'] !== this.numFloors) {
          this.numFloors = Math.max(1, Math.min(100, parameters['mazeZ']));
          changed = true;
        }
        if (parameters['mazeY'] != null) {
          parameters['mazeY'] = parseInt(parameters['mazeY']);
        }
        if (parameters['mazeY'] != null && parameters['mazeY'] === parameters['mazeY'] && parameters['mazeY'] !== this.mazeY) {
          this.mazeY = Math.max(5, Math.min(100, parameters['mazeY']));
          changed = true;
        }
        if (parameters['mazeX'] != null) {
          parameters['mazeX'] = parseInt(parameters['mazeX']);
        }
        if (parameters['mazeX'] != null && parameters['mazeX'] === parameters['mazeX'] && parameters['mazeX'] !== this.mazeX) {
          this.mazeX = Math.max(5, Math.min(100, parameters['mazeX']));
          changed = true;
        }
        if (this.numFloors * this.mazeY * this.mazeX > 30 * 30 * 30) {
          this.numFloors = Math.min(30, this.numFloors);
          this.mazeY = Math.min(30, this.mazeY);
          this.mazeX = Math.min(30, this.mazeX);
        }
        if (parameters['wallDensity'] != null) {
          parameters['wallDensity'] = parseInt(parameters['wallDensity']);
        }
        if (parameters['wallDensity'] != null && parameters['wallDensity'] === parameters['wallDensity'] && parameters['wallDensity'] !== this.wallDensity) {
          this.wallDensity = Math.max(0, Math.min(99, parameters['wallDensity']));
          changed = true;
        }
        if (parameters['speed'] != null) {
          parameters['speed'] = parseInt(parameters['speed']);
        }
        if (parameters['speed'] != null && parameters['speed'] === parameters['speed'] && parameters['speed'] !== this.player.moveSpeed) {
          this.player.moveSpeed = Math.max(1, Math.min(20, parameters['speed']));
        }
        if (parameters['colorAccent'] != null && parameters['colorAccent'] !== this.colorAccent) {
          this.colorAccent = parameters['colorAccent'];
          if(this.scene) this.setupLighting(); 
        }
        if (parameters['autoModeN'] != null) {
          parameters['autoModeN'] = parseInt(parameters['autoModeN']);
        }
        if (parameters['autoModeN'] != null && parameters['autoModeN'] === parameters['autoModeN'] && parameters['autoModeN'] !== this.autoModeN) {
          this.autoModeN = Math.max(0, parameters['autoModeN']);
        }
        if (parameters['botsNumber'] != null) {
          parameters['botsNumber'] = parseInt(parameters['botsNumber']);
           if (parameters['botsNumber'] === parameters['botsNumber'] && parameters['botsNumber'] !== this.maxBotsNumber) {
            this.maxBotsNumber = Math.max(0, Math.min(20, parameters['botsNumber']));
            changed = true; 
          }
        }
        if (parameters['botsSpeed'] != null) {
          parameters['botsSpeed'] = parseInt(parameters['botsSpeed']);
           if (parameters['botsSpeed'] === parameters['botsSpeed'] && parameters['botsSpeed'] !== this.botsSpeed) {
            this.botsSpeed = Math.max(1, Math.min(10, parameters['botsSpeed']));
          }
        }
        if (parameters['botsShoot'] != null && parameters['botsShoot'] !== this.botsShoot) {
          this.botsShoot = parameters['botsShoot']; 
        }

        if (changed && regenerate) {
          this.regenerateMaze();
        }
      }

      getParameters() {
        return {
          mazeZ: this.numFloors,
          mazeY: this.mazeY,
          mazeX: this.mazeX,
          wallDensity: this.wallDensity,
          speed: this.player.moveSpeed,
          colorAccent: this.colorAccent,
          autoModeN: this.autoModeN,
          botsNumber: this.maxBotsNumber,
          botsSpeed: this.botsSpeed,
          botsShoot: this.botsShoot,
        };
      }

      lock() {
        if (!this.locked) {
          this.controls.lock();
        }
      }

      unlock() {
        if (this.locked) {
          this.controls.unlock();
        }
      }

      isLocked() {
        return this.locked;
      }

      async init() {
        await RAPIER.init();
        this.physicsWorld = new RAPIER.World({ x: 0.0, y: -9.81 * 2.5, z: 0.0 }); 
        this.eventQueue = new RAPIER.EventQueue(true);

        this.setupRenderer();
        this.setupCamera(); 
        this.setupMaze(); 
        this.setupPlayerPhysics(); 
        this.setupLighting();
        this.setupEventListeners();
        this.eventsCallback({ event: 'new-maze', status: true, parameters: this.getParameters() });
        
        if(this.player.rapierBody) {
            const playerPhysicsPos = this.player.rapierBody.translation();
            this.camera.position.copy(playerPhysicsPos);
        }

        this.animate();
      }
      
      setupPlayerPhysics() {
        const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(
                this.player.startPosition.x,
                this.player.startPosition.y + this.player.height / 2, 
                this.player.startPosition.z
            )
            .lockRotations(true) 
            .setCanSleep(false);

        const capsuleHalfHeight = this.player.height / 2 - this.player.radius;
        const capsuleRadius = this.player.radius;
        const playerColliderDesc = RAPIER.ColliderDesc.capsule(capsuleHalfHeight, capsuleRadius)
            .setMass(1.0) 
            .setFriction(0.2) 
            .setRestitution(0.0)
            .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); 

        this.player.rapierBody = this.physicsWorld.createRigidBody(playerBodyDesc);
        const playerCollider = this.physicsWorld.createCollider(playerColliderDesc, this.player.rapierBody);
        playerCollider.userData = { type: 'player' };
      }


      setupRenderer() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
      }

      setupCamera(rotation = true) {
        this.camera.position.copy(this.player.position); 
        this.camera.position.y += this.player.height / 2; 
        if (rotation) {
          this.camera.rotation.set(0, 225 * Math.PI / 180, 0);
        }
      }

      goToStartPosition(rotation = true) {
        if (this.player.rapierBody) {
            this.player.rapierBody.setTranslation({
                x: this.player.startPosition.x,
                y: this.player.startPosition.y + this.player.height / 2, 
                z: this.player.startPosition.z
            }, true);
            this.player.rapierBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
            this.player.rapierBody.setAngvel({ x: 0, y: 0, z: 0 }, true); 
            this.player.onGround = false; 
            this.player.justJumped = false; 
        }
        
        if(this.player.rapierBody){ 
            const playerPhysicsPos = this.player.rapierBody.translation();
            this.camera.position.copy(playerPhysicsPos);
             this.player.position.set( playerPhysicsPos.x, playerPhysicsPos.y - this.player.height / 2, playerPhysicsPos.z);
        }
         if (rotation) {
          this.camera.rotation.set(0, 225 * Math.PI / 180, 0); 
        }
      }

      setupMaze() {
        if (this.physicsWorld) {
            const bodiesToRemove = [];
            this.physicsWorld.forEachRigidBody(body => {
                if (!this.player.rapierBody || body.handle !== this.player.rapierBody.handle) {
                    bodiesToRemove.push(body);
                }
            });
            bodiesToRemove.forEach(body => {
              for(let i = 0; i < body.numColliders(); ++i) {
                  const colHandle = body.collider(i).handle;
                  const col = this.physicsWorld.getCollider(colHandle);
                  if(col) this.physicsWorld.removeCollider(col, false);
              }
              this.physicsWorld.removeRigidBody(body);
            });
        }
        this.movingObjects.forEach(obj => {
            if (obj.mesh) this.scene.remove(obj.mesh);
        });
        this.movingObjects = [];

        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const startBoxMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const finishBoxMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const movingObjectMaterial = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 3 });
        const wallGeometry = new THREE.BoxGeometry(this.wallThickness, this.wallHeight, this.wallThickness);
        const edgesGeometry = new THREE.EdgesGeometry(wallGeometry);

        this.walls.forEach(wallMesh => this.scene.remove(wallMesh)); 
        this.walls = [];

        for (let floor = 0; floor < this.numFloors + 1; floor++) {
          for (let y = 0; y < this.maze[floor].length; y++) {
            for (let x = 0; x < this.maze[floor][y].length; x++) {
              if (this.maze[floor][y][x] === 1) {
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                const wallX = x * this.wallThickness;
                const wallY = this.wallHeight / 2 + floor * this.wallHeight;
                const wallZ = y * this.wallThickness;
                wallMesh.position.set(wallX, wallY, wallZ);
                this.scene.add(wallMesh);
                this.walls.push(wallMesh);
                const edgesMesh = new THREE.LineSegments(edgesGeometry, lineMaterial);
                edgesMesh.position.copy(wallMesh.position);
                this.scene.add(edgesMesh);

                let wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(wallX, wallY, wallZ);
                let wallColliderDesc = RAPIER.ColliderDesc.cuboid(this.wallThickness / 2, this.wallHeight / 2, this.wallThickness / 2)
                    .setFriction(0.2) 
                    .setRestitution(0.0)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                let rapierWallBody = this.physicsWorld.createRigidBody(wallBodyDesc);
                let wallCollider = this.physicsWorld.createCollider(wallColliderDesc, rapierWallBody);
                wallCollider.userData = { type: 'wall' };
              }
            }
          }

          if (floor === 0) { 
            const floorWidth = this.maze[floor][0].length * this.wallThickness;
            const floorDepth = this.maze[floor].length * this.wallThickness;
            const floorGeometry = new THREE.PlaneGeometry(floorWidth, floorDepth);
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            const floorMeshX = (this.maze[floor][0].length - 1) * this.wallThickness / 2;
            const floorMeshY = 0; 
            const floorMeshZ = (this.maze[floor].length - 1) * this.wallThickness / 2;
            floorMesh.position.set(floorMeshX, floorMeshY, floorMeshZ);
            this.scene.add(floorMesh);

            const floorColliderHeight = 0.1; 
            let floorBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(floorMeshX, floorMeshY - floorColliderHeight / 2, floorMeshZ); 
            let floorColliderDesc = RAPIER.ColliderDesc.cuboid(floorWidth / 2, floorColliderHeight / 2, floorDepth / 2)
                .setFriction(1.0)
                .setRestitution(0.0)
                .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
            let rapierFloorBody = this.physicsWorld.createRigidBody(floorBodyDesc);
            let floorCollider = this.physicsWorld.createCollider(floorColliderDesc, rapierFloorBody);
            floorCollider.userData = { type: 'wall' }; 
          }
        }

        const boxGeometry = new THREE.BoxGeometry(1, 1, 1);

        const startBoxPos = { x: 1, y: 1, floor: 0 };
        this.startBox = new THREE.Mesh(boxGeometry, startBoxMaterial);
        this.startBox.position.set(startBoxPos.x * this.wallThickness, this.wallHeightPart + startBoxPos.floor * this.wallHeight, startBoxPos.y * this.wallThickness);
        this.startBox.userData = { floor: startBoxPos.floor };
        this.scene.add(this.startBox);

        const finishPos = this.findFarthestPosition(this.maze, startBoxPos.x, startBoxPos.y, startBoxPos.floor);
        this.finishBox = new THREE.Mesh(boxGeometry, finishBoxMaterial);
        this.finishBox.position.set(finishPos.x * this.wallThickness, this.wallHeightPart + finishPos.floor * this.wallHeight, finishPos.y * this.wallThickness);
        this.finishBox.userData = { floor: finishPos.floor };
        this.scene.add(this.finishBox);

        if (this.physicsWorld) {
            const finishBoxRapierX = this.finishBox.position.x;
            const finishBoxRapierY = this.finishBox.position.y;
            const finishBoxRapierZ = this.finishBox.position.z;
            
            const finishBoxHalfExtents = { x: 0.5, y: 0.5, z: 0.5 }; 

            let finishBodyDesc = RAPIER.RigidBodyDesc.fixed()
                .setTranslation(finishBoxRapierX, finishBoxRapierY, finishBoxRapierZ);
            
            let finishColliderDesc = RAPIER.ColliderDesc.cuboid(finishBoxHalfExtents.x, finishBoxHalfExtents.y, finishBoxHalfExtents.z)
                .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); 
            
            let rapierFinishBody = this.physicsWorld.createRigidBody(finishBodyDesc);
            let finishCollider = this.physicsWorld.createCollider(finishColliderDesc, rapierFinishBody);
            finishCollider.userData = { type: 'finish' }; 
        }
        
        const startBoxPositionXf = this.startBox.position.x / this.wallThickness;
        const startBoxPositionYf = this.startBox.position.z / this.wallThickness;
        const startBoxPositionFLOORf = this.startBox.userData.floor;
        const finishBoxPositionXf = this.finishBox.position.x / this.wallThickness;
        const finishBoxPositionYf = this.finishBox.position.z / this.wallThickness;
        const finishBoxPositionFLOORf = this.finishBox.userData.floor;


        const freeCells = [];
        for (let floor = 0; floor < this.numFloors; floor++) {
          for (let y = 1; y < this.mazeY - 1; y++) {
            for (let x = 1; x < this.mazeX - 1; x++) {
              if (
                this.maze[floor][y][x] === 0 &&
                (Math.abs(startBoxPositionXf - x) >= 1 || Math.abs(startBoxPositionYf - y) >= 1 || Math.abs(startBoxPositionFLOORf - floor) >= 1) &&
                (Math.abs(finishBoxPositionXf - x) >= 1 || Math.abs(finishBoxPositionYf - y) >= 1 || Math.abs(finishBoxPositionFLOORf - floor) >= 1)
              ) {
                freeCells.push({ x, y, floor });
              }
            }
          }
        }
        const numObjects = Math.max(0, Math.min(this.maxBotsNumber, freeCells.length));
        this.shuffleArray(freeCells);
        
        for (let i = 0; i < numObjects; i++) {
          if (freeCells.length === 0) break;
          const cell = freeCells.splice(0, 1)[0];
          const botMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), movingObjectMaterial);
          const botInitialX = cell.x * this.wallThickness;
          const botInitialY = this.wallHeightPart + cell.floor * this.wallHeight;
          const botInitialZ = cell.y * this.wallThickness;
          botMesh.position.set(botInitialX, botInitialY, botInitialZ);
          this.scene.add(botMesh);

          const botBodyDesc = RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(botInitialX, botInitialY, botInitialZ)
            .setCanSleep(false)
            .lockRotations(true);

          const botColliderDesc = RAPIER.ColliderDesc.cuboid(0.5, 0.5, 0.5) 
            .setMass(0.5)
            .setFriction(0.5)
            .setRestitution(0.1)
            .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
          
          const rapierBotBody = this.physicsWorld.createRigidBody(botBodyDesc);
          const botRapierCollider = this.physicsWorld.createCollider(botColliderDesc, rapierBotBody);
          
          const botObject = {
            mesh: botMesh,
            rapierBody: rapierBotBody,
            id: `bot_${i}`,
            currentCell: { x: cell.x, y: cell.y, floor: cell.floor }, 
            startCell: { x: cell.x, y: cell.y, floor: cell.floor },
            targetCell: null,
            speed: this.botsSpeed, 
            lastKnownPlayerCell: null,
            lastSightCheck: null,
            availableCells: [],
            lastShotTime: 0, 
            shootInterval: 2 
          };
          botRapierCollider.userData = { type: 'bot', botId: botObject.id, botInstance: botObject };
          this.movingObjects.push(botObject);
        }
      }

      findFarthestPosition(maze, startX, startY, startFloor) {
        const floors = maze.length;
        const rows = maze[0].length;
        const cols = maze[0][0].length;
        const visited = Array.from({ length: floors }, () => Array.from({ length: rows }, () => Array(cols).fill(false)));
        const queue = [[startY, startX, startFloor, 0, null, 0]];
        const directions = [
          [-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]
        ];
        let maxTurns = 0;
        let maxSteps = 0;
        let farthestPos = { x: startX, y: startY, floor: startFloor };
        visited[startFloor][startY][startX] = true;
        while (queue.length > 0) {
          const [y, x, floor, turns, prevDir, steps] = queue.shift();
          if (turns > maxTurns || (turns === maxTurns && steps > maxSteps)) {
            maxTurns = turns;
            maxSteps = steps;
            farthestPos = { x, y, floor };
          }
          for (let dir = 0; dir < directions.length; dir++) {
            const [dy, dx, dFloor] = directions[dir];
            const ny = y + dy;
            const nx = x + dx;
            const nFloor = floor + dFloor;
            if (
              ny >= 0 &&
              ny < rows &&
              nx >= 0 &&
              nx < cols &&
              nFloor >= 0 &&
              nFloor < floors &&
              !visited[nFloor][ny][nx] &&
              maze[nFloor][ny][nx] === 0
            ) {
              let newTurns = turns;
              if (prevDir !== null && prevDir !== dir) {
                newTurns = turns + 1;
              }
              visited[nFloor][ny][nx] = true;
              queue.push([ny, nx, nFloor, newTurns, dir, steps + 1]);
            }
          }
        }
        return farthestPos;
      }

      shuffleArray(array, notOriginal = false) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + (1 - notOriginal)));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      setupLighting() {
        const colors = {
          neutral: 0xFFFFFF,
          red: 0xFF0000,
          green: 0x00FF00,
          blue: 0x0000FF,
          cyan: 0x00FFFF,
          magenta: 0xFF00FF,
          yellow: 0xFFFF00,
          orange: 0xFFA500
        };

        for (let i = this.scene.children.length - 1; i >= 0; --i) {
          if (
            this.scene.children[i] instanceof THREE.AmbientLight ||
            this.scene.children[i] instanceof THREE.DirectionalLight
          ) {
            this.scene.remove(this.scene.children[i]);
          }
        }
        const ambientLight = new THREE.AmbientLight(0x404040, 3);
        this.scene.add(ambientLight);

        let saturation = [0.1, 0.1, 0.1, 0.1];
        const r = Math.floor(Math.random() * 4);
        if (r === 0) {
          saturation = [0.35, 0.15, 0.3, 0.3];
        }
        else if (r === 1) {
          saturation = [0.15, 0.35, 0.3, 0.3];
        }
        else if (r === 2) {
          saturation = [0.3, 0.3, 0.35, 0.15];
        }
        else {
          saturation = [0.3, 0.3, 0.15, 0.35];
        }

        let color1, color2, color3, color4;
        if (colors[this.colorAccent] != null) {
          color1 = color2 = color3 = color4 = colors[this.colorAccent];
        }
        else if (this.colorAccent === 'random-per-maze') {
          const colorsList = [...Object.values(colors)];
          this.shuffleArray(colorsList);
          color1 = color2 = color3 = color4 = colorsList[0];
        }
        else if (this.colorAccent === 'random-per-side') {
          const colorsList = [...Object.values(colors)];
          this.shuffleArray(colorsList);
          color1 = colorsList[0];
          color2 = colorsList[1];
          color3 = colorsList[2];
          color4 = colorsList[3];
        }
        else {
          color1 = color2 = color3 = color4 = colors.neutral;
        }

        const directionalLight1 = new THREE.DirectionalLight(color1, saturation[0]);
        directionalLight1.position.set(0, 1, 1);
        this.scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(color2, saturation[1]);
        directionalLight2.position.set(0, 1, -1);
        this.scene.add(directionalLight2);

        const directionalLight3 = new THREE.DirectionalLight(color3, saturation[2]);
        directionalLight3.position.set(1, 1, 0);
        this.scene.add(directionalLight3);

        const directionalLight4 = new THREE.DirectionalLight(color4, saturation[3]);
        directionalLight4.position.set(-1, 1, 0);
        this.scene.add(directionalLight4);
      }

      setupEventListeners() {
        document.addEventListener('keydown', (event) => {
          switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.keys.forward = true; break;
            case 'ArrowDown':
            case 'KeyS': this.keys.backward = true; break;
            case 'ArrowLeft':
            case 'KeyA': this.keys.left = true; break;
            case 'ArrowRight':
            case 'KeyD': this.keys.right = true; break;
            case 'KeyC':
            case 'Space': this.keys.jump = true; break;
            case 'KeyP': this.saveImage(); break;
            case 'KeyT':
            case 'ShiftLeft':
            case 'ShiftRight':
              this.keys.shift = true; break;
          }
        });

        document.addEventListener('keyup', (event) => {
          switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': this.keys.forward = false; break;
            case 'ArrowDown':
            case 'KeyS': this.keys.backward = false; break;
            case 'ArrowLeft':
            case 'KeyA': this.keys.left = false; break;
            case 'ArrowRight':
            case 'KeyD': this.keys.right = false; break;
            case 'KeyG': this.goToStartPosition(); break;
            case 'KeyU': this.moveBotsToStartPositions = true; break;
            case 'KeyC':
            case 'Space': 
                this.keys.jump = false; 
                this.player.justJumped = false; 
                break;
            case 'KeyT':
            case 'ShiftLeft':
            case 'ShiftRight':
              this.keys.shift = false; break;
          }
        });

        window.addEventListener('resize', () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      updatePlayerOnGroundStatus() {
        if (!this.player.rapierBody || !this.physicsWorld) {
            this.player.onGround = false;
            return;
        }

        const playerCollider = this.player.rapierBody.collider(0); 
        if (!playerCollider) {
            this.player.onGround = false;
            return;
        }

        const bodyTranslation = this.player.rapierBody.translation();
        
        const rayOrigin = { x: bodyTranslation.x, y: bodyTranslation.y, z: bodyTranslation.z };
        const rayDirection = { x: 0, y: -1, z: 0 };
        const rayMaxToi = (this.player.height / 2) + 0.1; 

        const ray = new RAPIER.Ray(rayOrigin, rayDirection);
        
        const hit = this.physicsWorld.castRay(
            ray,
            rayMaxToi,
            true, 
            undefined, 
            undefined, 
            playerCollider 
        );

        this.player.onGround = !!hit;
      }
      
      hasLineOfSight(botObject) {
        if (!botObject.rapierBody || !this.player.rapierBody) return false;

        const botPos = botObject.rapierBody.translation();
        const playerPos = this.player.rapierBody.translation();
        
        const threeBotPos = new THREE.Vector3(botPos.x, botPos.y, botPos.z);
        const threePlayerPos = new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z);

        const toPlayer = new THREE.Vector3().subVectors(threePlayerPos, threeBotPos).normalize();
        const raycaster = new THREE.Raycaster(threeBotPos, toPlayer, 0.1, threeBotPos.distanceTo(threePlayerPos));
        
        const intersects = raycaster.intersectObjects(this.walls, false); 
        return intersects.length === 0;
      }

      isCellOccupied(x, y, floor) {
        const startBoxCellX = Math.floor(this.startBox.position.x / this.wallThickness);
        const startBoxCellMazeY = Math.floor(this.startBox.position.z / this.wallThickness);
        const startBoxCellFloor = this.startBox.userData.floor;

        if (floor === startBoxCellFloor && x === startBoxCellX && y === startBoxCellMazeY) {
          return true;
        }

        const finishBoxCellX = Math.floor(this.finishBox.position.x / this.wallThickness);
        const finishBoxCellMazeY = Math.floor(this.finishBox.position.z / this.wallThickness);
        const finishBoxCellFloor = this.finishBox.userData.floor;

        if (floor === finishBoxCellFloor && x === finishBoxCellX && y === finishBoxCellMazeY) {
          return true;
        }
        
        for (const obj of this.movingObjects) {
            if (obj.targetCell && obj.targetCell.x === x && obj.targetCell.y === y && obj.targetCell.floor === floor) {
                return true; 
            }
            if (obj.currentCell && obj.currentCell.x === x && obj.currentCell.y === y && obj.currentCell.floor === floor) {
                return true;
            }
        }
        return false;
      }
      
      _cleanupProjectileAssets(projectileData) { 
        if (projectileData.mesh) {
            this.scene.remove(projectileData.mesh);
            if (projectileData.mesh.geometry) projectileData.mesh.geometry.dispose();
            if (projectileData.mesh.material) projectileData.mesh.material.dispose();
            projectileData.mesh = null;
        }
        if (projectileData.rapierBody && this.physicsWorld && this.physicsWorld.getRigidBody(projectileData.rapierBody.handle)) { 
            const numColliders = projectileData.rapierBody.numColliders();
            for (let i = 0; i < numColliders; ++i) {
                const colliderHandle = projectileData.rapierBody.collider(0).handle; 
                const collider = this.physicsWorld.getCollider(colliderHandle);
                if (collider) {
                    this.physicsWorld.removeCollider(collider, false);
                }
            }
            this.physicsWorld.removeRigidBody(projectileData.rapierBody);
            projectileData.rapierBody = null;
        }
      }

      shootProjectile(shooterBot) {
        if (this.botsShoot === 'disable' || this.projectiles.length >= this.MAX_PROJECTILES_IN_SCENE || !this.player.rapierBody) {
            return;
        }

        const shooterPos = shooterBot.rapierBody.translation();
        const playerPos = this.player.rapierBody.translation();

        const direction = new THREE.Vector3(playerPos.x - shooterPos.x, playerPos.y - shooterPos.y, playerPos.z - shooterPos.z).normalize();
        
        let speed = this.player.moveSpeed * this.PROJECTILE_BASE_SPEED_FACTOR;
        if (this.botsShoot === 'hard') {
            speed = this.player.moveSpeed * this.PROJECTILE_HARD_SPEED_FACTOR;
        }

        const projectileMesh = new THREE.Mesh(this.projectileGeometry, this.projectileMaterial);
        
        const projectileOffset = 0.5; 
        const initialProjectilePos = {
            x: shooterPos.x + direction.x * projectileOffset,
            y: shooterPos.y + direction.y * projectileOffset,
            z: shooterPos.z + direction.z * projectileOffset
        };
        projectileMesh.position.set(initialProjectilePos.x, initialProjectilePos.y, initialProjectilePos.z);
        this.scene.add(projectileMesh);

        const projectileBodyDesc = RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(initialProjectilePos.x, initialProjectilePos.y, initialProjectilePos.z)
            .setLinvel(direction.x * speed, direction.y * speed, direction.z * speed)
            .setGravityScale(0.0, true) 
            .setCcdEnabled(true); 

        const projectileColliderDesc = RAPIER.ColliderDesc.ball(this.PROJECTILE_RADIUS)
            .setDensity(0.1) 
            .setRestitution(0.1)
            .setFriction(0.1)
            .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);

        const rapierProjectileBody = this.physicsWorld.createRigidBody(projectileBodyDesc);
        const projCollider = this.physicsWorld.createCollider(projectileColliderDesc, rapierProjectileBody);

        const projectileObject = {
            mesh: projectileMesh,
            rapierBody: rapierProjectileBody,
            initialPosition: { ...initialProjectilePos },
            creationTime: performance.now(),
            toBeRemoved: false
        };
        projCollider.userData = { type: 'projectile', projectileInstance: projectileObject };
        
        this.projectiles.push(projectileObject);
      }


      animate() {
        requestAnimationFrame(() => this.animate());
        const time = performance.now();
        const delta = Math.min((time - this.prevTime) / 1000, 0.1);
        this.prevTime = time;
        
        if (this.moveBotsToStartPositions) {
            this.movingObjects.forEach(obj => {
                if (obj.rapierBody) {
                    const startCellPos = {
                        x: obj.startCell.x * this.wallThickness,
                        y: this.wallHeightPart + obj.startCell.floor * this.wallHeight,
                        z: obj.startCell.y * this.wallThickness
                    };
                    obj.rapierBody.setTranslation(startCellPos, true);
                    obj.rapierBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    obj.targetCell = null; 
                    obj.lastKnownPlayerCell = null;
                }
            });
            this.moveBotsToStartPositions = false;
        }

        if (this.player.rapierBody) {
            this.updatePlayerOnGroundStatus(); 

            if (this.keys.jump && this.player.onGround && !this.player.justJumped) {
                this.player.rapierBody.applyImpulse({ x: 0, y: this.player.jumpImpulse, z: 0 }, true);
                this.player.onGround = false; 
                this.player.justJumped = true; 
            }

            const moveSpeed = (this.player.moveSpeed) * (this.keys.shift ? 2 : 1);
            const directionInput = new THREE.Vector3();
            const frontVector = this.frontVectorBase.clone().applyQuaternion(this.camera.quaternion);
            const sideVector = this.sideVectorBase.clone().applyQuaternion(this.camera.quaternion);
            frontVector.y = 0; 
            sideVector.y = 0;

            if (this.keys.forward) directionInput.add(frontVector);
            if (this.keys.backward) directionInput.sub(frontVector);
            if (this.keys.left) directionInput.sub(sideVector);
            if (this.keys.right) directionInput.add(sideVector);
            
            let targetVelX = 0;
            let targetVelZ = 0;

            if (directionInput.lengthSq() > 0) { 
                directionInput.normalize();
                targetVelX = directionInput.x * moveSpeed;
                targetVelZ = directionInput.z * moveSpeed;
            }
            
            const currentLinvel = this.player.rapierBody.linvel();
            this.player.rapierBody.setLinvel({
                x: targetVelX,
                y: currentLinvel.y, 
                z: targetVelZ
            }, true);
        }
        
        this.movingObjects.forEach(obj => {
            if (!obj.rapierBody) return;

            const botRapierPos = obj.rapierBody.translation();
            const currentBotCellForAI = {
                x: Math.round(botRapierPos.x / this.wallThickness), 
                y: Math.round(botRapierPos.z / this.wallThickness),
                floor: Math.round((botRapierPos.y - this.wallHeightPart) / this.wallHeight) 
            };
            obj.currentCell = currentBotCellForAI; 

            const currentTime = time / 1000;
            let hasSight = obj.lastSightCheck?.hasSight || false;
            if (!obj.lastSightCheck || currentTime - obj.lastSightCheck.time > 0.5) {
              hasSight = this.hasLineOfSight(obj);
              obj.lastSightCheck = { hasSight, time: currentTime };
            }

            if (hasSight && this.player.rapierBody) {
              const playerPos = this.player.rapierBody.translation();
              obj.lastKnownPlayerCell = { 
                x: Math.round(playerPos.x / this.wallThickness), 
                y: Math.round(playerPos.z / this.wallThickness), 
                floor: Math.round((playerPos.y - (this.player.height/2) ) / this.wallHeight)
              };
              if (this.botsShoot !== 'disable' && (currentTime - (obj.lastShotTime || 0) > obj.shootInterval)) {
                this.shootProjectile(obj);
                obj.lastShotTime = currentTime;
              }
            }
            
            let needsNewTarget = true;
            if (obj.targetCell) {
                const targetWorldX = obj.targetCell.x * this.wallThickness;
                const targetWorldZ = obj.targetCell.y * this.wallThickness;
                const distSqToTarget = (botRapierPos.x - targetWorldX)**2 + (botRapierPos.z - targetWorldZ)**2;
                if (distSqToTarget > (this.wallThickness * 0.3)**2) { 
                    needsNewTarget = false; 
                }
            }

            if (needsNewTarget) {
                obj.availableCells = [];
                const directions = [ { dy: -1, dx: 0, dFloor: 0 }, { dy: 1, dx: 0, dFloor: 0 }, { dy: 0, dx: -1, dFloor: 0 }, { dy: 0, dx: 1, dFloor: 0 } ];

                directions.forEach(dir => {
                    const nFloor = currentBotCellForAI.floor + dir.dFloor;
                    const ny = currentBotCellForAI.y + dir.dy;
                    const nx = currentBotCellForAI.x + dir.dx;
                    if ( nFloor >= 0 && nFloor < this.maze.length &&
                         ny >= 0 && ny < this.maze[nFloor].length &&
                         nx >= 0 && nx < this.maze[nFloor][0].length &&
                         this.maze[nFloor][ny][nx] === 0 &&
                         !this.isCellOccupied(nx, ny, nFloor)
                    ) {
                        obj.availableCells.push({ x: nx, y: ny, floor: nFloor });
                    }
                });

                if (obj.availableCells.length > 0) {
                    if (obj.lastKnownPlayerCell) {
                        let minDistance = Infinity;
                        let nextCell = obj.availableCells[0];
                        obj.availableCells.forEach(cell => {
                            const distance = Math.abs(cell.x - obj.lastKnownPlayerCell.x) +
                                Math.abs(cell.y - obj.lastKnownPlayerCell.y) +
                                Math.abs(cell.floor - obj.lastKnownPlayerCell.floor);
                            if (distance < minDistance || (distance === minDistance && Math.random() < 0.5)) {
                                minDistance = distance;
                                nextCell = cell;
                            }
                        });
                        obj.targetCell = nextCell;
                    } else {
                        obj.targetCell = obj.availableCells[Math.floor(Math.random() * obj.availableCells.length)];
                    }
                } else {
                    obj.targetCell = currentBotCellForAI; 
                }
            }

            if (obj.targetCell) {
                const targetWorldX = obj.targetCell.x * this.wallThickness;
                const targetWorldZ = obj.targetCell.y * this.wallThickness;
                
                const directionToTarget = new THREE.Vector3(
                    targetWorldX - botRapierPos.x,
                    0, 
                    targetWorldZ - botRapierPos.z
                );

                if (directionToTarget.lengthSq() > 0.01) {
                    directionToTarget.normalize();
                    obj.rapierBody.setLinvel({
                        x: directionToTarget.x * obj.speed,
                        y: obj.rapierBody.linvel().y, 
                        z: directionToTarget.z * obj.speed
                    }, true);
                } else {
                    obj.rapierBody.setLinvel({ x: 0, y: obj.rapierBody.linvel().y, z: 0 }, true);
                }
            } else {
                 obj.rapierBody.setLinvel({ x: 0, y: obj.rapierBody.linvel().y, z: 0 }, true);
            }
        });

        if (this.physicsWorld) {
            this.physicsWorld.step(this.eventQueue); 
        }
        
        this.eventQueue.drainCollisionEvents((handle1, handle2, started) => {
            if (!started) return;

            const collider1 = this.physicsWorld.getCollider(handle1);
            const collider2 = this.physicsWorld.getCollider(handle2);

            if (!collider1 || !collider2) return;

            const data1 = collider1.userData;
            const data2 = collider2.userData;

            const getProjectileInstance = (data) => {
                if (data && data.type === 'projectile') return data.projectileInstance;
                return null;
            };

            const projInstance1 = getProjectileInstance(data1);
            const projInstance2 = getProjectileInstance(data2);

            if (projInstance1) { 
                if (data2) {
                    if (data2.type === 'player') {
                        this.goToStartPosition(false);
                        projInstance1.toBeRemoved = true;
                    } else if (data2.type === 'wall' || data2.type === 'bot' || data2.type === 'projectile' || data2.type === 'finish') { 
                        projInstance1.toBeRemoved = true;
                    }
                }
            }
            
            if (projInstance2) { 
                 if (data1) { 
                    if (data1.type === 'player') {
                        this.goToStartPosition(false);
                        projInstance2.toBeRemoved = true;
                    } else if (data1.type === 'wall' || data1.type === 'bot' || data1.type === 'projectile' || data1.type === 'finish') { 
                        projInstance2.toBeRemoved = true;
                    }
                }
            }
            
            const isPlayerFinishCollision = (d1, d2) => {
                return (d1 && d1.type === 'player' && d2 && d2.type === 'finish') ||
                       (d1 && d1.type === 'finish' && d2 && d2.type === 'player');
            };

            if (isPlayerFinishCollision(data1, data2)) {
                if (this.autoModeN !== 0) {
                    this.autoModeNCounter += 1;
                    if (this.autoModeNCounter % this.autoModeN === 0) {
                        this.setParameters({
                            mazeZ: this.numFloors + 1,
                            mazeY: this.mazeY + 1,
                            mazeX: this.mazeX + 1
                        }, true); 
                    } else {
                        this.regenerateMaze();
                    }
                } else {
                    this.autoModeNCounter = 0;
                    this.regenerateMaze();
                }
            }
        });

        const newProjectilesList = [];
        for (const proj of this.projectiles) {
            if (proj.toBeRemoved) {
                this._cleanupProjectileAssets(proj);
                continue;
            }

            if (!proj.rapierBody || !proj.mesh) { 
                this._cleanupProjectileAssets(proj); 
                continue;
            }

            const pos = proj.rapierBody.translation();
            proj.mesh.position.set(pos.x, pos.y, pos.z);

            const distVec = new THREE.Vector3(pos.x - proj.initialPosition.x, pos.y - proj.initialPosition.y, pos.z - proj.initialPosition.z);
            const maxDist = this.PROJECTILE_MAX_DISTANCE_FACTOR * this.wallThickness;
            if (distVec.lengthSq() > maxDist * maxDist) {
                this._cleanupProjectileAssets(proj);
            } else {
                newProjectilesList.push(proj);
            }
        }
        this.projectiles = newProjectilesList;
        
        if (this.player.rapierBody) {
            const playerPhysicsPosition = this.player.rapierBody.translation();
            this.camera.position.copy(playerPhysicsPosition); 
            
            this.player.position.set(
                playerPhysicsPosition.x,
                playerPhysicsPosition.y - this.player.height / 2, 
                playerPhysicsPosition.z
            );
        }

        this.movingObjects.forEach(obj => {
            if (obj.rapierBody) {
                const pos = obj.rapierBody.translation();
                const rot = obj.rapierBody.rotation();
                obj.mesh.position.set(pos.x, pos.y, pos.z);
                obj.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
            }
        });

        this.renderer.render(this.scene, this.camera);
      }

      regenerateMaze() {
        const objectsToRemoveFromScene = [];
        this.scene.children.forEach(child => {
            if (child !== this.camera && !(child instanceof THREE.Light)) { 
                objectsToRemoveFromScene.push(child);
            }
        });
        objectsToRemoveFromScene.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
            this.scene.remove(child);
        });
        this.walls = [];
        
        this.projectiles.forEach(proj => this._cleanupProjectileAssets(proj));
        this.projectiles = [];
        
        this.movingObjects = [];

        this.maze = this.generateRandomMaze(this.mazeY, this.mazeX, this.numFloors);
        
        this.setupLighting(); 
        this.setupMaze(); 
        
        if (this.player.rapierBody && this.physicsWorld) {
             for(let i = 0; i < this.player.rapierBody.numColliders(); ++i) {
                const colHandle = this.player.rapierBody.collider(i).handle;
                const col = this.physicsWorld.getCollider(colHandle);
                if(col) this.physicsWorld.removeCollider(col, false);
             }
            this.physicsWorld.removeRigidBody(this.player.rapierBody);
            this.player.rapierBody = null;
        }
        this.setupPlayerPhysics(); 
        
        this.goToStartPosition(true); 

        this.eventsCallback({ event: 'new-maze', status: true, parameters: this.getParameters() });
      }

      saveImage() {
        this.renderer.render(this.scene, this.camera);
        const imgData = this.renderer.domElement.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = imgData;
        link.download = 'maze_screenshot.png';
        link.click();
      }
    }

    function timeStep() {
      timeState += 1;
      timeInfo.innerHTML = new Date(1000 * timeState).toISOString().substr(11, 8);
      setTimeout(() => timeStep(), 1000);
    }

    const settingsNames = {
      mazeX: 'mz_maze_mini2_x_rjs3_finish',
      mazeY: 'mz_maze_mini2_y_rjs3_finish',
      mazeZ: 'mz_maze_mini2_z_rjs3_finish',
      wallDensity: 'mz_maze_mini2_wall_density_rjs3_finish',
      speed: 'mz_maze_mini2_speed_rjs3_finish',
      colorAccent: 'mz_maze_mini2_color_accent_rjs3_finish',
      autoModeN: 'mz_maze_mini2_auto_mode_n_rjs3_finish',
      botsNumber: 'mz_maze_mini2_bots_rjs3_finish',
      botsSpeed: 'mz_maze_mini2_bots_speed_rjs3_finish',
      botsShoot: 'mz_maze_mini2_bots_shoot_rjs3_finish'
    };
    const canvas = document.getElementById('gameCanvas1');
    const playButton = document.getElementById('playButton');
    const regenerateMazeButton = document.getElementById('regenerateMazeButton');
    const regenerateLightingColorsButton = document.getElementById('regenerateLightingColorsButton');
    const resetSettingsButton = document.getElementById('resetSettingsButton');
    const blocker = document.getElementById('blocker');
    const mazeZ = document.getElementById('mazeZ');
    const mazeY = document.getElementById('mazeY');
    const mazeX = document.getElementById('mazeX');
    const wallDensity = document.getElementById('wallDensity');
    const speed = document.getElementById('speed');
    const colorAccent = document.getElementById('colorAccent');
    const autoModeN = document.getElementById('autoModeN');
    const botsNumber = document.getElementById('botsNumber');
    const botsSpeed = document.getElementById('botsSpeed');
    const botsShoot = document.getElementById('botsShoot');
    const timeInfo = document.getElementById('timeInfo');
    let timeState = 0;
    mazeX.value = localStorage.getItem(settingsNames.mazeX) || '10';
    mazeY.value = localStorage.getItem(settingsNames.mazeY) || '10';
    mazeZ.value = localStorage.getItem(settingsNames.mazeZ) || '1';
    wallDensity.value = localStorage.getItem(settingsNames.wallDensity) || '50';
    speed.value = localStorage.getItem(settingsNames.speed) || '5';
    colorAccent.value = localStorage.getItem(settingsNames.colorAccent) || 'neutral';
    autoModeN.value = localStorage.getItem(settingsNames.autoModeN) || '1';
    botsNumber.value = localStorage.getItem(settingsNames.botsNumber) || '0'; 
    botsSpeed.value = localStorage.getItem(settingsNames.botsSpeed) || '3';
    botsShoot.value = localStorage.getItem(settingsNames.botsShoot) || 'disable'; 

    botsNumber.disabled = false; 
    botsSpeed.disabled = false;
    botsShoot.disabled = false; 

    const game = new GameMap(
      canvas,
      mazeZ.value,
      mazeY.value,
      mazeX.value,
      wallDensity.value,
      speed.value,
      colorAccent.value,
      autoModeN.value,
      botsNumber.value, 
      botsSpeed.value,  
      botsShoot.value 
    );

    game.setEventsCallback((event) => {
      if (event.event === 'lock' && event.status === true) {
        blocker.style.display = 'none';
      }
      else if (event.event === 'unlock' && event.status === true) {
        blocker.style.display = '';
      }
      else if (event.event === 'new-maze' && event.status === true) {
        mazeZ.value = event.parameters['mazeZ'];
        mazeY.value = event.parameters['mazeY'];
        mazeX.value = event.parameters['mazeX'];
        botsNumber.value = event.parameters['botsNumber'];
        botsSpeed.value = event.parameters['botsSpeed'];
        botsShoot.value = event.parameters['botsShoot'];

        localStorage.setItem(settingsNames.mazeX, mazeX.value);
        localStorage.setItem(settingsNames.mazeY, mazeY.value);
        localStorage.setItem(settingsNames.mazeZ, mazeZ.value);
        localStorage.setItem(settingsNames.botsNumber, botsNumber.value);
        localStorage.setItem(settingsNames.botsSpeed, botsSpeed.value);
        localStorage.setItem(settingsNames.botsShoot, botsShoot.value);
        timeState = 0;
      }
    });
    
    (async () => {
        await game.init();
    })();

    playButton.addEventListener('click', (event) => {
      game.setParameters({
        speed: speed.value,
        colorAccent: colorAccent.value,
        autoModeN: autoModeN.value,
        botsNumber: botsNumber.value,
        botsSpeed: botsSpeed.value,
        botsShoot: botsShoot.value
      }, false);
      game.lock();
    });
    regenerateMazeButton.addEventListener('click', (event) => {
      game.setParameters({ 
        mazeZ: mazeZ.value,
        mazeY: mazeY.value,
        mazeX: mazeX.value,
        wallDensity: wallDensity.value,
        speed: speed.value, 
        colorAccent: colorAccent.value,
        autoModeN: autoModeN.value,
        botsNumber: botsNumber.value,
        botsSpeed: botsSpeed.value,
        botsShoot: botsShoot.value
      }, true); 
    });
    regenerateLightingColorsButton.addEventListener('click', (event) => {
      game.setParameters({ 
        colorAccent: colorAccent.value
      }, false); 
    });
    resetSettingsButton.addEventListener('click', (event) => {
      if (!confirm('Are you sure you want to reset all settings?')) {
        return;
      }
      for (const key of Object.values(settingsNames)) {
        localStorage.removeItem(key);
      }
      window.location.reload();
    });
    setTimeout(() => timeStep(), 1000);
    mazeX.addEventListener('input', () => {
      localStorage.setItem(settingsNames.mazeX, mazeX.value);
    });
    mazeY.addEventListener('input', () => {
      localStorage.setItem(settingsNames.mazeY, mazeY.value);
    });
    mazeZ.addEventListener('input', () => {
      localStorage.setItem(settingsNames.mazeZ, mazeZ.value);
    });
    wallDensity.addEventListener('input', () => {
      localStorage.setItem(settingsNames.wallDensity, wallDensity.value);
    });
    speed.addEventListener('input', () => {
      localStorage.setItem(settingsNames.speed, speed.value);
    });
    colorAccent.addEventListener('input', () => {
      localStorage.setItem(settingsNames.colorAccent, colorAccent.value);
    });
    autoModeN.addEventListener('input', () => {
      localStorage.setItem(settingsNames.autoModeN, autoModeN.value);
    });
    botsNumber.addEventListener('input', () => {
      localStorage.setItem(settingsNames.botsNumber, botsNumber.value);
    });
    botsSpeed.addEventListener('input', () => {
      localStorage.setItem(settingsNames.botsSpeed, botsSpeed.value);
    });
    botsShoot.addEventListener('input', () => {
        localStorage.setItem(settingsNames.botsShoot, botsShoot.value);
        if(game) { 
            game.setParameters({ botsShoot: botsShoot.value }, false);
        }
    });
  </script>
</body>

</html>